# Controversial Personal Opinions
These are my personal opinions about programming.
These options aren't are based upon personal observations.

## Why Software Fails at Hiring
Hiring software developers is a self-inflicted mortal wound of business.
There are no agreed upon conventions, credentials, education, or any other factor that determines competence in software.
That lack of agreement is an indication of immaturity, faulty expectations, and bias.

Other industries have solved this problem.
For example there exists a common set of credentials for teachers, real estate agents, doctors, lawyers, truck drivers, police, fire fighters, electricians, and so forth.
In any other industry if a given person lacks the minimum required credentials they cannot work for anybody at all.
No excuses.
This sets a common minimum baseline of competence, ethics, and accepted practice.

Business appears to not want to solve this problem as software developers are typically viewed as a disposable cost center to the business.
That means a business is certainly not going to directly invest in the advancement of a developer's technical education unless a regulatory action or contractual obligation requires otherwise.
Developers are also viewed as lacking loyalty and willing to switch employment frequently.
Developer can expect to achieve a 20% raise by switching employers every two years for the first decade of their career while only gaining perhaps a 3% raise from remaining loyal, so there is no incentive to retain developers or invest in them.

This hiring problem is the result wanting the freedom of maximum selection from among a group of applicants without concern for the specifics of what you want to select, which is uncertainty avoidance.
You cannot have your cake and eat it too.
As a result software hiring is often a race to the bottom with low retention that results in over paying for the least qualified applicant.

## How Education Factors Into Software
Generally speaking education is defined as the following:

* A bachelor's degree means a person can communicate, such as write emails with the appropriate levels of specificity.
* A master's degree means a person can perform a profession with advanced critical and/or original reasoning.
* A doctoral degree means a person can conduct research.

From the most generalized of considerations that's it.
Education means nothing more than those few things, but those few things are exceedingly important to certain careers.

So, what does that mean for software?
In most cases, nothing relevant.
In most cases software skills can be self-taught.
I am self-taught and can perform software development objectively better than many university educated developers with regards to speed of delivery, originality, and quality/speed of product.

It is necessary to debunk many false assumptions of education.
First, education exists as a formal model to expand knowledge with qualified guidance.
Second, education is not a license to practice in any profession.
For example you need a law license to practice law, but you need a law degree to apply for the licensing process.
Education is a prerequisite but the license to practice is the license not the education.
Third, education is not directly an indicator of performance or potential in any regard, but is indirectly strongly correlated with both performance and potential.
Forth, education is frequently used to determine professional compatibility, such that people with similar educations will write software in similar ways.
That is true, but it's also both extremely good and bad, because it's a monocultural where all benefits and consequences are greatly multiplied at considerable risk.

Monoculture aside, a bachelors degree in computer science is little more than worthless.
It costs a tremendous amount of money for an insufficient increase of value.
My recommendation to get the most of your money is to get a communications degree and teach yourself programming.

Graduate degrees, on the other hand, are extremely valuable to computer science.
Graduate degrees, masters and doctorate, provide a substantially better education than what you can provide to yourself.
Graduate degrees also increase your earning potential and probability of promotion in the corporate world.

## How to Promote
In most larger companies there are two separate paths of elevation:
* Management of administration, often referred to as leadership.
* Scientist, often referred to as a principle or technical fellow.

The managers typically become the leaders of the organizations who own administrative, man power, and vision for an organization.
Conversely, the scientists perform discovery, innovation, research, and risk analysis.
Even the US military makes these distinctions with commissioned officers versus warrant officers.
Both positions require extremely large amounts of effort in order for a person to achieve success, but they require personality traits that are diametrically opposed.

To be successful as a manager of people/organizations you need an insane level of conscientiousness.
Conscientiousness means an ability to perceive the world around you and all the numerous variables it comprises.
Conscientiousness is often associated the factors of conservatism and administrative success such as dutifulness, orderliness, industriousness, patriotism, and various other rigidly perceived qualifiers associated with hard work.

To be successful as a scientist you need some level of passion and innovation, which are highly correlated with creativity.
Creativity is highly correlated with openness, which explains why software developers with a passion for software are willing to continue writing software outside of work and generally prefer open source contributions.
Contrary to conscientiousness, which is associated with conservatism, creativity and openness are generally associated with personality traits associated with concepts of liberalism.
Scientist personality types tend to prefer transparency and precision as primary personality traits.

People are not self-aware enough to objectively determine whether they are more creative or more conscientious.
Self-evaluations are biased towards the work product performed and that bias is magnified by the commitment and work required to elevate a developer's skills and managerial prowess.
As such developers worthy of promotion should be tested to determine if they are more creative or more conscientious.
The conclusion of such testing should serve as a very strong guide for which path a person should elevate into.

A secondary factor to consider is that every organization has a greater demand for managerial leaders than it does for scientists.
As such scientist type positions are more rare and more competitive.
That means you must be substantially more intelligent than your managerial peers with an amazing ability to balance insane levels of objectivity, novelty, and creativity.
A partial exception is the military where scientist types, warrant officers, are rare but the demand far out paces the available candidate pool almost guaranteeing early selection and promotion according to minimal acceptable criteria.

## How to Hire Developers
If a business wants to select the most ideal candidate from a given pool of potential employees there are simple things to do.
First, know exactly what you want.
As somebody who has interviewed a lot most businesses have absolutely no idea what they want from a developer.
For example a full stack developer will write some services or define some APIs and jump into the front end if the front end developers need help, but its all extremely vague.
If you don't know what you want, as specifically as possible, you have no idea how to achieve candidate selection, because you need to have known goals to properly separate candidates aside from bias.
Here are some examples of specificity:

* Define a practice of test automation and enforce it with using a scheme of continuous integration.
* Define performance targets and the means to measure such.
* Define internal APIs as integration points between separately constructed applications and/or data systems.
* Put dynamic text on screen.

Second, make a determination about the minimum intelligence required to achieve the desired tasks.
Then test the candidates for intelligence.
Candidates that lack the necessary intelligence to achieve the desired tasks are immediately disqualified.
No subjective technical assessment is required, but recommended only to determine level of experience and areas of interest.
This is the number one area where most businesses fail.

There is no compromise on the issue of minimal required cognitive competence as doing so will result in a greater investment of accommodations than that future employee will ever return to the business.
We were able to measure various incidents of this when I was at Travelocity, most of which involved introducing use of jQuery where such usage introduced considerable product harm in production.
The increased costs associated with accommodating to employees that are incapable of performing their designated responsibilities are not immediately obvious.
Many of these costs are economic in nature and are passed directly to lower product quality and increased external liabilities.

It is ideal to find the perfect candidate who is currently performing all specified tasks for some other employer using your technology stack so they can immediately solve world hunger on day 1 of their employment.
That's not going to happen.
Instead a person smart enough to perform the specified tasks will figure them out provided the opportunity and sufficient time to write the necessary corresponding code.

Third, don't let developers have any part of the selection process of other developers.
This imposes a bias the business can never recover from.
Some developers are able to identify these biases and select candidates in an objective manner, but most will fail miserably in this regard as most people are incapable of recognizing bias on any level.
In my personal experience interviewing objective selection criteria conducted by developers occurred about 1 out of 12 times.
So don't do it.
Objectivity, by the way, requires uniform measures that are relevant to the hiring goal, as opposed to that which is familiar or comforting to the developer performing the selection.
Instead keep bias where it belongs: at the stakeholders.
Stake holders include hiring managers, product owners, higher leadership, and so forth.

## How to Retain Super Competent Developers
Retaining excellent developers requires far less effort than most businesses suspect.
First, pay these developers at market rate.
This is a challenge because market rate can change rapidly and increase drastically.
It doesn't hurt to be transparent about compensation.
If it becomes known that one developer earns substantially more than another developer it means either the business has made a fundamental flaw of personal judgement about their employees or that the business is more interested in retaining one employee than the other.

Second, give the developer challenging work.
This work should feel exploratory and be filled with discovery, research, and and original effort to create something helpful.
If the work is not advancing the technical capabilities of a top performer then they will go somewhere else that does have such work even if that means taking less pay.

When challenging work is not available then give this developer no work.
A top performer will find things to do that are beneficial to the business or software at large.
This sounds counter-intuitive, but super competent developers only achieved super competence by solving hard problems which requires initiative and insane amounts of practice.
If these people cannot perform the practice they need they will go elsewhere and sometimes are willing to do so for less pay.

## How to Train Developers
First, set the acceptable baseline extremely high.
Product quality is a direct reflection of how high or low you define your level of acceptance.
As such the acceptable baseline must be an agreement between stakeholders and technology leadership where technology leadership is making cost/analysis decisions about the personnel they have available.

Bear in mind that despite what many developers claim a high baseline will not result in lower developer productivity or slower delivery.
Counter-intuitively a higher baseline will result in faster code delivery because developers will accept certain risks more directly opposed to offloading everything into a giant stack of dependencies each with their own concerns and risks.

The risk with setting the baseline of acceptable delivery too high is that it exposes the developers that were never really qualified to write that code in the first place.
To be clear when quality and delivery standards are raised all developers will require some time to adjust.
The developers that aren't qualified to perform are those who cannot make the necessary adjustments provided sufficient time and mentorship.

Once a high performance baseline is established it must be enforced.
Automated enforcement is most ideal.
Examples of automated enforcement include things like static analysis, test automation, thorough type definitions, accessibility checks, execution performance checks, and so forth.
Automated enforcement is ideal because it does not show bias and does not bend to personal and emotional concerns.

On top of the automated checks there must also be code reviews.
Automated enforcement will not catch everything.
Putting a different set of eyes on code if often sufficient to catch issues the code author may have over looked.

## Why JavaScript Needs Frameworks
The glue that holds all things together on the front end is the Document Object Model (DOM).
It is the backbone of everything in web browsers.
The DOM is how JavaScript binds to markup and the thing that presentation addresses.
A failure to understand the DOM results in a failure of appreciation of performance, accessibility, and some aspects of front end security.

**Most developers are scared to death of the DOM.**
I mean horrifically terrified and would rather cut a finger off or switch careers for half the money.
It is a phobia and its completely irrational.
This is not a technology failure, it's a social failure.

There are some reasons for this and none of those reasons have anything to do with technology of the DOM itself, despite what these developers say.
This becomes self-evident when you confront developers about their fears as the responses are often some form of poorly misinformed assumptions and deflections that resemble narcissism.

First, front end developers are not properly trained by schools, businesses, boot camps, or just about anywhere else.
That is a bad state of affairs for software.
Developers that are smart enough to self educate **and** above the necessary cognitive threshold to understand the DOM **and** capable of measuring things will just figure it out on their own, but that is an incredible small subset of total developers.
Some developers are above the minimum required cognitive threshold and have appropriate mentorship to learn and/or appreciate the technology, but that is perhaps even more rare, unfortunately.

Second, the DOM is a tree model.
Tree models implicitly require a formal understanding of relationships as abstractions, which is highly imperative.
There is a minimum cognitive performance, such as IQ, required to understand relationships as abstractions.
The concept is astonishingly simple which leaves no room for a grey area.
If you are smart enough to understand the concept it will only take a few hours to learn the necessary APIs and master the concept, because there isn't much to it.
If you aren't smart enough learning this is a near impossibility.

This means the DOM, the glue that makes everything work, discriminates on the basis of intelligence.
For business that is problematic.
Most of the work on the front end is a matter of displaying text on screen and trivial amounts of presentation or minor interactions.
From a business perspective these requirements are assumed to be highly repetitive and low skill.
Not as low skill as data entry, but not skilled enough to write original software.

This is a problem.
It isn't a technology problem as the technology works amazingly well and allows developers to create things that scale very efficiently.
It is a business problem.
More specifically it is a hiring problem.
Actually, its a training and selection problem, but business wants this to be a hiring problem so that's what it is.

## What Makes the DOM Challenging
In the fewest possible words: choice.
In relational models the path between two points is a series of segments between the various nodes that comprise the path.
At each segment a choice must be made as to which path to take to creep closer to the destination.
A person with insufficient cognitive ability can handle one or two choices but beyond two nodes in the path they get lost.
The computational overhead to successfully navigate by forming a series of independent decisions at each node is overwhelming.

From a behavioral perspective this is an incredibly intriguing field of study because most people do not possess the executive functioning to think in this manner.
What's more interesting is that it isn't directly associated with brain size or intelligence.
Social insects like ants and bees, for example, perform exceedingly well at this.
Tool using birds, especially ravens and crows, and also perform well at this. 
In some cases these other animals can perform better than many people.

The most interesting part of this is what makes the smart people different, because it isn't computational capacity as you might expect.
Instead the difference primarily comes down to speed of executive functioning, as in how fast you can make an arbitrary decision, and the ability to regard each of these decisions as arbitrary and potentially wrong.
Perhaps apathy is a good description.
For these people there is little or no regard to the correctness of an arbitrary choice.
We can call this a *no cost decision*.
If a choice moves the person closer to the destination the choice is good and no further thought is given.
If a choice moves the person further from the destination the choice is bad and hopefully the next choice is better, but if not they must backtrack one or more steps.
Each decision is formed in relative isolation with little care.
There is almost no critical examination performed until the destination is reached, at which point maybe the person will review their path to become more efficient the next time.

Now compare that back to the people who cannot perform.
Each decision is examined in much greater depth against a series of cost/benefit analysis considerations.
We can call that a *high cost decision*.
Each decision is expensive and worse the weight of a former decision remains into the next decision until they become emotionally overwhelming, as if being crushed by an emotional debt.

Thinking about this abstractly it doesn't appear to make sense because this entire process of thought exercise is so trivial and not associated with any consequence.
It is different, though, at programming time when you must write the instructions and carefully consider how this works instruction by instruction.
At instruction writing time the perceived consequences of an incorrect approach are perceived as very real, because there is there is an emotional burden that builds with each instruction.

If you are smart enough to consider from a variety of choices extremely quickly and not care how wrong each choice is in isolation there is no emotional burden and insufficient perceived penalty.
After a few hours of practice the patterns of navigating the tree models at hand become well known, mastery sets in, and confidence is achieved.
If should be noted this mode of behavior extends well beyond the DOM towards a variety of real world scenarios, often considered visual abstract modeling.
Advanced visual reasoning capabilities are also associated with certain childhood learning disorders such as autism, dyslexia, and dysgraphia.

Other situations in which these behaviors apply: land navigation, visual abstract pattern analysis, original tool creation, threat modeling.
Further interesting is that each of those other listed skills are closely associated with basic soldiering skills but not associated with formal education or academics as those are commonly perceived.
It must be quite frustrating when some dumb infantry soldier can spontaneously master this primitive programming skill after just a few hours of practice while many formally educated more intelligent programmers are permanently incapable of grasping this capability.

## Performance
Performance evaluation requires measures.
Software execution performance requires measuring execution time against a clock and comparing that clock time to the clock time derived from an alternate approach.
If a developer does not do this they are guessing.

The problem with guessing at performance is that such guesses are wrong about 80% of the time.
Of those wrong guesses more than half, perhaps 50% of all guesses, are catastrophically wrong by several orders of magnitude.
That shouldn't be a surprise.
People most typically guess out of convenience for self-serving validations, which can't be trusted.

Since performance, when done properly, requires evidence from clock times it is strenuously objective.
Such objectivity is the most useful means to determine the character of a developer.
A developer must either accept, discard, or ignore evidence presented to them.
The motivations for any such decision can indicate a developer's thinking when presented with a challenge.

For example, is the developer discarding the evidence because it destroys or invalidates positions they require to perform work?
If a developer is provided evidence that querySelectors are, at best, 400x slower than other means of DOM access they may discard such evidence if they cannot do their jobs without querySelectors.
That is a form of integrity violation, which could indicate narcissism but more likely demonstrates a lesser self-serving bias of face-saving behaviors.
